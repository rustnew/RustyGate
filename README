

# 🚀 RustyGate — Reverse Proxy / API Gateway en Rust

> **Un reverse proxy ultra-performant, extensible et observable, écrit 100% en Rust avec Actix Web.**  
> Conçu pour les microservices, les architectures cloud, et les environnements exigeants.

---

## 🧭 Table des matières

- [🚀 Présentation](#-présentation)
- [✨ Fonctionnalités](#-fonctionnalités)
- [🏗️ Architecture](#️-architecture)
- [📦 Installation](#-installation)
- [⚙️ Configuration](#️-configuration)
- [🧪 Développement](#-développement)
- [📊 Observabilité](#-observabilité)
- [📈 Benchmark](#-benchmark)
- [📅 Roadmap](#-roadmap)
- [📜 Licence](#-licence)

---

## 🚀 Présentation

**RustyGate** est un reverse proxy / API Gateway moderne, léger et performant, écrit en Rust. Il permet de :

- Router les requêtes HTTP(S) vers des backends dynamiques.
- Appliquer des middlewares (auth, rate limit, CORS…).
- Load balancer entre plusieurs instances.
- Exposer des métriques (Prometheus), logs structurés, et traces (OpenTelemetry).
- Recharger la configuration à chaud sans downtime.

Contrairement aux solutions comme Traefik ou Kong, RustyGate est **minimaliste, ultra-rapide, et conçu pour être étendu via des plugins WASM**.

---

## ✨ Fonctionnalités

| Fonctionnalité | Statut | Description |
|----------------|--------|-------------|
| ✅ Routing basique | Phase 1 | Route les requêtes vers des backends définis en YAML |
| ✅ Forward HTTP complet | Phase 1 | Supporte GET, POST, PUT, DELETE, etc. |
| ✅ Timeout & retry | Phase 1 | Timeout configurable (5s par défaut) |
| ✅ Logs structurés JSON | Phase 1 | Via `tracing` — méthode, path, backend, durée |
| ✅ Headers debug | Phase 1 | `X-RustyGate-Backend`, `X-RustyGate-Duration-ms` |
| ✅ Test d’intégration | Phase 1 | Test automatisé avec backend mock |
| ✅ Benchmark de perf | Phase 1 | Mesure req/s et latence avec `criterion` |
| ⏳ Middlewares (JWT, rate limit) | Phase 2 | À venir |
| ⏳ Load Balancing | Phase 3 | À venir |
| ⏳ Tracing distribué | Phase 4 | À venir |
| ⏳ Reload à chaud | Phase 5 | À venir |
| ⏳ Plugins WASM | Phase 6 | À venir |

---

## 🏗️ Architecture

```mermaid
graph TD
    A[Client] --> B[RustyGate:8080]
    B --> C{Routing Engine}
    C --> D[Forward to Backend]
    D --> E[Return Response]
    B --> F[/metrics:8081]
```

### Technologies

- **Serveur HTTP** : `actix-web`
- **Async Runtime** : `tokio`
- **Configuration** : `serde_yaml`
- **Client HTTP** : `reqwest`
- **Logs** : `tracing` + `tracing-subscriber`
- **Benchmark** : `criterion`

---

## 📦 Installation

### Prérequis

- Rust 1.70+
- Cargo

### Depuis les sources

```bash
git clone https://github.com/tonuser/rustygate.git
cd rustygate
cargo build --release
```

### Lancer

```bash
cargo run
```

→ Écoute sur `http://localhost:8080`

---

## ⚙️ Configuration

La configuration se fait via `config/default.yaml` :

```yaml
routes:
  - path: "/api/test"
    backend: "http://localhost:8001"
  - path: "/api/users"
    backend: "http://localhost:8002"
```

### Exemple d’utilisation

Lance un backend mock :

```bash
cd /tmp && echo "Hello from backend!" > index.html && python3 -m http.server 8001
```

Puis :

```bash
curl http://localhost:8080/api/test
# → "Hello from backend!"
```

---

## 🧪 Développement

### Lancer les tests

```bash
cargo test --test integration
```

### Lancer le benchmark

```bash
cargo bench --bench proxy_bench
```

→ Génère un rapport dans `target/criterion/`

### Structure du projet

```
src/
├── main.rs
├── server.rs
├── config.rs
├── proxy_handler.rs
tests/
└── integration.rs
benches/
└── proxy_bench.rs
config/
└── default.yaml
```

---

## 📊 Observabilité

### Logs

Les logs sont au format JSON :

```json
{
  "timestamp": "2025-09-08T15:25:50Z",
  "level": "INFO",
  "fields": {
    "message": "Requête reçue",
    "method": "GET",
    "path": "/api/test"
  }
}
```

### Métriques (à venir)

Exposées sur `:8081/metrics` au format Prometheus.

### Tracing (à venir)

Intégration OpenTelemetry → traces dans Jaeger.

---

## 📈 Benchmark

Exemple de résultat :

```
proxy_single_request
                        time:   [1.23 ms 1.25 ms 1.27 ms]
                        thrpt:  [787 req/s 798 req/s 810 req/s]
```

→ RustyGate peut traiter **~800 requêtes par seconde** sur une machine de dev.

---

## 📅 Roadmap

| Phase | Objectif | Statut |
|-------|----------|--------|
| 1 | MVP : Serveur + Proxy Basique | ✅ Terminé |
| 2 | Middlewares (JWT, rate limit) | 🟡 En cours |
| 3 | Load Balancing + Health Checks | ⏳ À venir |
| 4 | Tracing distribué (Jaeger) | ⏳ À venir |
| 5 | Reload config à chaud | ⏳ À venir |
| 6 | Plugins WASM | ⏳ À venir |
| 7 | Production Ready (Docker, CI/CD) | ⏳ À venir |

---

## 📜 Licence

MIT License — voir [LICENSE](LICENSE)

---

## 💬 Contribuer

Les contributions sont les bienvenues !

1. Fork le dépôt
2. Crée une branche (`git checkout -b feat/nouvelle-fonction`)
3. Commit tes changements (`git commit -am 'Add nouvelle fonction'`)
4. Push (`git push origin feat/nouvelle-fonction`)
5. Ouvre une Pull Request

---

> ✅ **RustyGate — Parce que ton infrastructure mérite la vitesse, la sécurité, et la fiabilité de Rust.**
