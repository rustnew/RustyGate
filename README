

# ğŸš€ RustyGate â€” Reverse Proxy / API Gateway en Rust

> **Un reverse proxy ultra-performant, extensible et observable, Ã©crit 100% en Rust avec Actix Web.**  
> ConÃ§u pour les microservices, les architectures cloud, et les environnements exigeants.

---

## ğŸ§­ Table des matiÃ¨res

- [ğŸš€ PrÃ©sentation](#-prÃ©sentation)
- [âœ¨ FonctionnalitÃ©s](#-fonctionnalitÃ©s)
- [ğŸ—ï¸ Architecture](#ï¸-architecture)
- [ğŸ“¦ Installation](#-installation)
- [âš™ï¸ Configuration](#ï¸-configuration)
- [ğŸ§ª DÃ©veloppement](#-dÃ©veloppement)
- [ğŸ“Š ObservabilitÃ©](#-observabilitÃ©)
- [ğŸ“ˆ Benchmark](#-benchmark)
- [ğŸ“… Roadmap](#-roadmap)
- [ğŸ“œ Licence](#-licence)

---

## ğŸš€ PrÃ©sentation

**RustyGate** est un reverse proxy / API Gateway moderne, lÃ©ger et performant, Ã©crit en Rust. Il permet de :

- Router les requÃªtes HTTP(S) vers des backends dynamiques.
- Appliquer des middlewares (auth, rate limit, CORSâ€¦).
- Load balancer entre plusieurs instances.
- Exposer des mÃ©triques (Prometheus), logs structurÃ©s, et traces (OpenTelemetry).
- Recharger la configuration Ã  chaud sans downtime.

Contrairement aux solutions comme Traefik ou Kong, RustyGate est **minimaliste, ultra-rapide, et conÃ§u pour Ãªtre Ã©tendu via des plugins WASM**.

---

## âœ¨ FonctionnalitÃ©s

| FonctionnalitÃ© | Statut | Description |
|----------------|--------|-------------|
| âœ… Routing basique | Phase 1 | Route les requÃªtes vers des backends dÃ©finis en YAML |
| âœ… Forward HTTP complet | Phase 1 | Supporte GET, POST, PUT, DELETE, etc. |
| âœ… Timeout & retry | Phase 1 | Timeout configurable (5s par dÃ©faut) |
| âœ… Logs structurÃ©s JSON | Phase 1 | Via `tracing` â€” mÃ©thode, path, backend, durÃ©e |
| âœ… Headers debug | Phase 1 | `X-RustyGate-Backend`, `X-RustyGate-Duration-ms` |
| âœ… Test dâ€™intÃ©gration | Phase 1 | Test automatisÃ© avec backend mock |
| âœ… Benchmark de perf | Phase 1 | Mesure req/s et latence avec `criterion` |
| â³ Middlewares (JWT, rate limit) | Phase 2 | Ã€ venir |
| â³ Load Balancing | Phase 3 | Ã€ venir |
| â³ Tracing distribuÃ© | Phase 4 | Ã€ venir |
| â³ Reload Ã  chaud | Phase 5 | Ã€ venir |
| â³ Plugins WASM | Phase 6 | Ã€ venir |

---

## ğŸ—ï¸ Architecture

```mermaid
graph TD
    A[Client] --> B[RustyGate:8080]
    B --> C{Routing Engine}
    C --> D[Forward to Backend]
    D --> E[Return Response]
    B --> F[/metrics:8081]
```

### Technologies

- **Serveur HTTP** : `actix-web`
- **Async Runtime** : `tokio`
- **Configuration** : `serde_yaml`
- **Client HTTP** : `reqwest`
- **Logs** : `tracing` + `tracing-subscriber`
- **Benchmark** : `criterion`

---

## ğŸ“¦ Installation

### PrÃ©requis

- Rust 1.70+
- Cargo

### Depuis les sources

```bash
git clone https://github.com/tonuser/rustygate.git
cd rustygate
cargo build --release
```

### Lancer

```bash
cargo run
```

â†’ Ã‰coute sur `http://localhost:8080`

---

## âš™ï¸ Configuration

La configuration se fait via `config/default.yaml` :

```yaml
routes:
  - path: "/api/test"
    backend: "http://localhost:8001"
  - path: "/api/users"
    backend: "http://localhost:8002"
```

### Exemple dâ€™utilisation

Lance un backend mock :

```bash
cd /tmp && echo "Hello from backend!" > index.html && python3 -m http.server 8001
```

Puis :

```bash
curl http://localhost:8080/api/test
# â†’ "Hello from backend!"
```

---

## ğŸ§ª DÃ©veloppement

### Lancer les tests

```bash
cargo test --test integration
```

### Lancer le benchmark

```bash
cargo bench --bench proxy_bench
```

â†’ GÃ©nÃ¨re un rapport dans `target/criterion/`

### Structure du projet

```
src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ server.rs
â”œâ”€â”€ config.rs
â”œâ”€â”€ proxy_handler.rs
tests/
â””â”€â”€ integration.rs
benches/
â””â”€â”€ proxy_bench.rs
config/
â””â”€â”€ default.yaml
```

---

## ğŸ“Š ObservabilitÃ©

### Logs

Les logs sont au format JSON :

```json
{
  "timestamp": "2025-09-08T15:25:50Z",
  "level": "INFO",
  "fields": {
    "message": "RequÃªte reÃ§ue",
    "method": "GET",
    "path": "/api/test"
  }
}
```

### MÃ©triques (Ã  venir)

ExposÃ©es sur `:8081/metrics` au format Prometheus.

### Tracing (Ã  venir)

IntÃ©gration OpenTelemetry â†’ traces dans Jaeger.

---

## ğŸ“ˆ Benchmark

Exemple de rÃ©sultat :

```
proxy_single_request
                        time:   [1.23 ms 1.25 ms 1.27 ms]
                        thrpt:  [787 req/s 798 req/s 810 req/s]
```

â†’ RustyGate peut traiter **~800 requÃªtes par seconde** sur une machine de dev.

---

## ğŸ“… Roadmap

| Phase | Objectif | Statut |
|-------|----------|--------|
| 1 | MVP : Serveur + Proxy Basique | âœ… TerminÃ© |
| 2 | Middlewares (JWT, rate limit) | ğŸŸ¡ En cours |
| 3 | Load Balancing + Health Checks | â³ Ã€ venir |
| 4 | Tracing distribuÃ© (Jaeger) | â³ Ã€ venir |
| 5 | Reload config Ã  chaud | â³ Ã€ venir |
| 6 | Plugins WASM | â³ Ã€ venir |
| 7 | Production Ready (Docker, CI/CD) | â³ Ã€ venir |

---

## ğŸ“œ Licence

MIT License â€” voir [LICENSE](LICENSE)

---

## ğŸ’¬ Contribuer

Les contributions sont les bienvenues !

1. Fork le dÃ©pÃ´t
2. CrÃ©e une branche (`git checkout -b feat/nouvelle-fonction`)
3. Commit tes changements (`git commit -am 'Add nouvelle fonction'`)
4. Push (`git push origin feat/nouvelle-fonction`)
5. Ouvre une Pull Request

---

> âœ… **RustyGate â€” Parce que ton infrastructure mÃ©rite la vitesse, la sÃ©curitÃ©, et la fiabilitÃ© de Rust.**
